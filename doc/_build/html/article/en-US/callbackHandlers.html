
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Callback Handlers &#8212; Miruken-ES5  documentation</title>
    
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Context" href="context.html" />
    <link rel="prev" title="About" href="about.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="context.html" title="Context"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="about.html" title="About"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Miruken-ES5  documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="callback-handlers">
<h1>Callback Handlers<a class="headerlink" href="#callback-handlers" title="Permalink to this headline">¶</a></h1>
<p><strong>Namespace</strong>
&gt;miruken.callback</p>
<p>CallbackHandlers are where you implement the business logic for your Protocols.
They play a key role in the polymorphic behavior of miruken because
you can have multiple implementations of the same protocol, and the appropriate implementation will be chosen at runtime base on
the current application context.</p>
<p>It is often said that the difference between a <strong>framework</strong> and a <strong>library</strong> is that a library is something you call in your code and a framework
is something that calls your code.  Miruken is definately a framework.  Miruken calls your code, and the code that it calls resides in
CallbackHandlers.</p>
<p>Throughout this explaination of Callbackhandlers we will be using a very simple Logging Protocol.</p>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a><a href="#id3"><span class="problematic" id="id4">`</span></a>Javascript</p>
<dl class="docutils">
<dt>const Logging = Protocol.extend({</dt>
<dd>debug(message){}</dd>
</dl>
<p>});</p>
<p><a href="#id5"><span class="problematic" id="id6">``</span></a><a href="#id7"><span class="problematic" id="id8">`</span></a></p>
<p>Now lets create a very simple LoggingHandler to discuss.</p>
<p><a href="#id9"><span class="problematic" id="id10">``</span></a><a href="#id11"><span class="problematic" id="id12">`</span></a>Javascript</p>
<dl class="docutils">
<dt>let LoggingHandler = CallbackHandler.extend(Logging, {</dt>
<dd><dl class="first docutils">
<dt>debug(message) {</dt>
<dd>//log message here</dd>
</dl>
<p class="last">};</p>
</dd>
</dl>
<p>});</p>
<p><a href="#id13"><span class="problematic" id="id14">``</span></a><a href="#id15"><span class="problematic" id="id16">`</span></a></p>
<p>Here we are creating a LoggingHandler and there are three things to notice.  First, CallbackHandlers extend from CallbackHandler.
Second, they can explicitly adopt a Protocol by passing in that Protocol to the extend function. Here LoggingHandler explicitly
adopts the Logging protocol by passing Logging in to extend. Third, the implementation for the debug method is done with an object
literal that is passed in as the second parameter.</p>
<p>###Explicit Protocol Adoption</p>
<p>Explicit Protocol adoption is done by passing one or more protocols into the extend method, and then implementing
one or more of the members of each protocol. You do not have to implement all the members of a protocol.  The full
implementation can be spread across many CallbackHandlers if it makes sense for your application.</p>
<p><a href="#id17"><span class="problematic" id="id18">``</span></a><a href="#id19"><span class="problematic" id="id20">`</span></a>Javascript</p>
<dl class="docutils">
<dt>let LoggingHandler = CallbackHandler.extend(Logging, {</dt>
<dd><dl class="first docutils">
<dt>debug(message) {</dt>
<dd>//log message here</dd>
</dl>
<p class="last">};</p>
</dd>
</dl>
<p>});</p>
<dl class="docutils">
<dt>describe(“LoggingHandler”, () =&gt; {</dt>
<dd><dl class="first docutils">
<dt>it(“explicitly adopts the Loggin Protocol”, () =&gt; {</dt>
<dd>Logging.adoptedBy(LoggingHandler).should.be.true;</dd>
</dl>
<p class="last">});</p>
</dd>
</dl>
<p>});</p>
<p><a href="#id21"><span class="problematic" id="id22">``</span></a><a href="#id23"><span class="problematic" id="id24">`</span></a></p>
<p>You can see in the test above that Logging is adopted by LoggingHandler.</p>
<p>###Implicit Protocol Implementations</p>
<p>Implicit Protocol implementation does not require you to pass in the Protocols to the extend method.
At runtime methods will be matched by method name only and will be ignored by StrictProtocols and strict method execution.</p>
<p><a href="#id25"><span class="problematic" id="id26">``</span></a><a href="#id27"><span class="problematic" id="id28">`</span></a>Javascript</p>
<dl class="docutils">
<dt>let LoggingHandler = CallbackHandler.extend({</dt>
<dd><dl class="first docutils">
<dt>debug(message) {</dt>
<dd>//log message here</dd>
</dl>
<p class="last">};</p>
</dd>
</dl>
<p>});</p>
<dl class="docutils">
<dt>describe(“LoggingHandler”, () =&gt; {</dt>
<dd><dl class="first docutils">
<dt>it(“implicitly implements the Loggin Protocol”, () =&gt; {</dt>
<dd>Logging.adoptedBy(LoggingHandler).should.be.false;</dd>
</dl>
<p class="last">});</p>
</dd>
</dl>
<div class="section" id="id29">
<h2>});<a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h2>
<p>See the [Protocol](Protocol.md) documentation for more information on StrictProtocols.</p>
<p>###Polymorphism
You can create multiple implementations for Protocols in your application.
Using the Logging Protocol above, we could have a NullLogger that is simply a noop.
This could be handy for running in production when you don’t want the app logging to the browser console.</p>
<p><a href="#id30"><span class="problematic" id="id31">``</span></a><a href="#id32"><span class="problematic" id="id33">`</span></a>Javascript</p>
<dl class="docutils">
<dt>let NullLoggingHandler = CallbackHandler.extend(Logging, {</dt>
<dd>debug(message) {};</dd>
</dl>
<p>});</p>
<p><a href="#id34"><span class="problematic" id="id35">``</span></a><a href="#id36"><span class="problematic" id="id37">`</span></a></p>
<p>We could also create an ObservableLoggingHandler to use during unit testing.</p>
<p><a href="#id38"><span class="problematic" id="id39">``</span></a><a href="#id40"><span class="problematic" id="id41">`</span></a>Javascript
let debugCalled = false;
let ObservableLoggingHandler = CallbackHandler.extend(Logging, {</p>
<blockquote>
<div><dl class="docutils">
<dt>debug(message) {</dt>
<dd>debugCalled = true;</dd>
</dl>
<p>};</p>
</div></blockquote>
<p>});</p>
<p><a href="#id42"><span class="problematic" id="id43">``</span></a><a href="#id44"><span class="problematic" id="id45">`</span></a></p>
<p>During development and debugging you will probably want a ConsoleLoggingHandler that just
logs messages out to the browser console.</p>
<p><a href="#id46"><span class="problematic" id="id47">``</span></a><a href="#id48"><span class="problematic" id="id49">`</span></a>Javascript</p>
<dl class="docutils">
<dt>let ConsoleLoggingHandler = CallbackHandler.extend(Logging, {</dt>
<dd><dl class="first docutils">
<dt>debug(message) {</dt>
<dd>console.log(message);</dd>
</dl>
<p class="last">};</p>
</dd>
</dl>
<p>});</p>
<p><a href="#id50"><span class="problematic" id="id51">``</span></a><a href="#id52"><span class="problematic" id="id53">`</span></a></p>
<p>Also, handy in production would be an HttpLoggingHandler that sends errors to the server to be logged.
Lets add error to the Logging Protocol and implement http error logging.</p>
<p><a href="#id54"><span class="problematic" id="id55">``</span></a><a href="#id56"><span class="problematic" id="id57">`</span></a>Javascript</p>
<dl class="docutils">
<dt>let Logging = Protocol.extend({</dt>
<dd>debug(message){},
error(message){}</dd>
</dl>
<p>});</p>
<dl class="docutils">
<dt>let HttpLoggingHandler = CallbackHandler.extend(Logging, {</dt>
<dd><dl class="first docutils">
<dt>error(message) {</dt>
<dd><dl class="first docutils">
<dt>return $http.post(“/api/log”, {</dt>
<dd>level  : “error”,
message: message</dd>
</dl>
<p class="last">})</p>
</dd>
</dl>
<p class="last">};</p>
</dd>
</dl>
<p>});</p>
<p><a href="#id58"><span class="problematic" id="id59">``</span></a>`
<em>$http is the http provider in angular</em></p>
<p>###Executing CallbackHandler Methods</p>
<p>####Directly</p>
<p>CallbackHandlers have a toDelegate() method, so they can be passed directly into a Protocol and then executed.
This is very usefull for unit testing of your CallbackHandlers.</p>
<p><a href="#id60"><span class="problematic" id="id61">``</span></a><a href="#id62"><span class="problematic" id="id63">`</span></a>JavaScript</p>
<p>let handler = new ObservableLoggingHandler();
Logging(handler).debug(“My Message”);</p>
<p><a href="#id64"><span class="problematic" id="id65">``</span></a><a href="#id66"><span class="problematic" id="id67">`</span></a></p>
<p>####In Context
In production code however, most the time CallbackHandlers will be added to a context, and then
the context will be passed in to the protocol.</p>
<p><a href="#id68"><span class="problematic" id="id69">``</span></a><a href="#id70"><span class="problematic" id="id71">`</span></a>JavaScript</p>
<p>let context = new Context();
context.addHandler(new ObservableLoggingHandler());
Logging(context).debug(“My Message”);</p>
<p><a href="#id72"><span class="problematic" id="id73">``</span></a><a href="#id74"><span class="problematic" id="id75">`</span></a></p>
<p>Now in the setup portion of our application we could set up different loggers depending on the environment.</p>
<p><a href="#id76"><span class="problematic" id="id77">``</span></a><a href="#id78"><span class="problematic" id="id79">`</span></a>JavaScript</p>
<dl class="docutils">
<dt>switch (env) {</dt>
<dd><dl class="first last docutils">
<dt>case “DEV”:</dt>
<dd>rootContext.addHandler(new ConsoleLoggingHandler());</dd>
<dt>case “PROD”:</dt>
<dd>rootContext.addHandler(new NullLoggingHandler());
rootContext.addHandler(new HttpLoggingHandler());
break;</dd>
<dt>default:</dt>
<dd>rootContext.addHandler(new NullLoggingHandler());</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p><a href="#id80"><span class="problematic" id="id81">``</span></a><a href="#id82"><span class="problematic" id="id83">`</span></a></p>
<p>In prod, calling <cite>Logging(context).debug(“My debug message”)</cite> would call the debug method on the NullLoggingHandler, but calling
<cite>Logging(context).error(“Something really bad happened”)</cite> would call the error method on the HttpLoggingHandler.</p>
<p>If a Protocol member is called that has no implementation, an error will be thrown.
For example, if debug is called, but no CallbackHandler is found that implements debug, you will see an error in the console with the following message:</p>
<p><code class="docutils literal"><span class="pre">`</span>
<span class="pre">&quot;CallbackHandler</span> <span class="pre">has</span> <span class="pre">no</span> <span class="pre">method</span> <span class="pre">'debug'&quot;</span>
<span class="pre">`</span></code></p>
<p>###Composition With $composer
$composer represents the current execution context.</p>
<p>We just saw that CallbackHandlers are most often executed through a Protocol within a context, but what happens
when you want to call a Protocol from within a CallbackHandler? What context should you use? That is where the $composer comes in.</p>
<p>As an example, lets create an Http Protocol whose implementation will post messages to the server.</p>
<p><a href="#id84"><span class="problematic" id="id85">``</span></a><a href="#id86"><span class="problematic" id="id87">`</span></a>JavaScript
const Http = Protocol.extend({</p>
<blockquote>
<div>post(url, data){}</div></blockquote>
<p>});</p>
<p><a href="#id88"><span class="problematic" id="id89">``</span></a><a href="#id90"><span class="problematic" id="id91">`</span></a></p>
<p>Now we can use the Http Protocol and $composer inside of the HttpLoggingHandler instead of $Http.</p>
<p><a href="#id92"><span class="problematic" id="id93">``</span></a><a href="#id94"><span class="problematic" id="id95">`</span></a>Javascript</p>
<dl class="docutils">
<dt>let HttpLoggingHandler = CallbackHandler.extend(Logging, {</dt>
<dd><dl class="first docutils">
<dt>error(message) {</dt>
<dd><dl class="first docutils">
<dt>return Http($composer).post(“/api/log”, {</dt>
<dd>level  : “error”,
message: message</dd>
</dl>
<p class="last">});</p>
</dd>
</dl>
<p class="last">};</p>
</dd>
</dl>
<p>});</p>
<p><a href="#id96"><span class="problematic" id="id97">``</span></a><a href="#id98"><span class="problematic" id="id99">`</span></a></p>
<p>###$NOT_HANDLED</p>
<p>If for any reason your CallbackHandler cannot handle the request, you can always <cite>return $NOT_HANDLED;</cite>
and miruken will continue looking for another CallbackHandler that can handle the request.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Callback Handlers</a><ul>
<li><a class="reference internal" href="#id29">});</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="about.html"
                        title="previous chapter">About</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="context.html"
                        title="next chapter">Context</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/article/en-US/callbackHandlers.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="context.html" title="Context"
             >next</a> |</li>
        <li class="right" >
          <a href="about.html" title="About"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Miruken-ES5  documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Miruken.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.2.
    </div>
  </body>
</html>